import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-JOH2SX6U.js";

// ../../../node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js
var Sr = function(r, e) {
  return Sr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, o) {
    t.__proto__ = o;
  } || function(t, o) {
    for (var n in o)
      Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);
  }, Sr(r, e);
};
function T(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Sr(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Rr(r, e, t, o) {
  function n(i) {
    return i instanceof t ? i : new t(function(f) {
      f(i);
    });
  }
  return new (t || (t = Promise))(function(i, f) {
    function c(m) {
      try {
        a2(o.next(m));
      } catch (h) {
        f(h);
      }
    }
    function u(m) {
      try {
        a2(o.throw(m));
      } catch (h) {
        f(h);
      }
    }
    function a2(m) {
      m.done ? i(m.value) : n(m.value).then(c, u);
    }
    a2((o = o.apply(r, e || [])).next());
  });
}
function $(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, o, n, i, f;
  return f = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (f[Symbol.iterator] = function() {
    return this;
  }), f;
  function c(a2) {
    return function(m) {
      return u([a2, m]);
    };
  }
  function u(a2) {
    if (o)
      throw new TypeError("Generator is already executing.");
    for (; f && (f = 0, a2[0] && (t = 0)), t; )
      try {
        if (o = 1, n && (i = a2[0] & 2 ? n.return : a2[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, a2[1])).done)
          return i;
        switch (n = 0, i && (a2 = [a2[0] & 2, i.value]), a2[0]) {
          case 0:
          case 1:
            i = a2;
            break;
          case 4:
            return t.label++, { value: a2[1], done: false };
          case 5:
            t.label++, n = a2[1], a2 = [0];
            continue;
          case 7:
            a2 = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a2[0] === 6 || a2[0] === 2)) {
              t = 0;
              continue;
            }
            if (a2[0] === 3 && (!i || a2[1] > i[0] && a2[1] < i[3])) {
              t.label = a2[1];
              break;
            }
            if (a2[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a2;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a2);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a2 = e.call(r, t);
      } catch (m) {
        a2 = [6, m], n = 0;
      } finally {
        o = i = 0;
      }
    if (a2[0] & 5)
      throw a2[1];
    return { value: a2[0] ? a2[1] : void 0, done: true };
  }
}
function I(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], o = 0;
  if (t)
    return t.call(r);
  if (r && typeof r.length == "number")
    return { next: function() {
      return r && o >= r.length && (r = void 0), { value: r && r[o++], done: !r };
    } };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function w(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var o = t.call(r), n, i = [], f;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = o.next()).done; )
      i.push(n.value);
  } catch (c) {
    f = { error: c };
  } finally {
    try {
      n && !n.done && (t = o.return) && t.call(o);
    } finally {
      if (f)
        throw f.error;
    }
  }
  return i;
}
function A(r, e, t) {
  if (t || arguments.length === 2)
    for (var o = 0, n = e.length, i; o < n; o++)
      (i || !(o in e)) && (i || (i = Array.prototype.slice.call(e, 0, o)), i[o] = e[o]);
  return r.concat(i || Array.prototype.slice.call(e));
}
function C(r) {
  return this instanceof C ? (this.v = r, this) : new C(r);
}
function Lr(r, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var o = t.apply(r, e || []), n, i = [];
  return n = {}, f("next"), f("throw"), f("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n;
  function f(l) {
    o[l] && (n[l] = function(y) {
      return new Promise(function(g, x) {
        i.push([l, y, g, x]) > 1 || c(l, y);
      });
    });
  }
  function c(l, y) {
    try {
      u(o[l](y));
    } catch (g) {
      h(i[0][3], g);
    }
  }
  function u(l) {
    l.value instanceof C ? Promise.resolve(l.value.v).then(a2, m) : h(i[0][2], l);
  }
  function a2(l) {
    c("next", l);
  }
  function m(l) {
    c("throw", l);
  }
  function h(l, y) {
    l(y), i.shift(), i.length && c(i[0][0], i[0][1]);
  }
}
function Cr(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof I == "function" ? I(r) : r[Symbol.iterator](), t = {}, o("next"), o("throw"), o("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function o(i) {
    t[i] = r[i] && function(f) {
      return new Promise(function(c, u) {
        f = r[i](f), n(c, u, f.done, f.value);
      });
    };
  }
  function n(i, f, c, u) {
    Promise.resolve(u).then(function(a2) {
      i({ value: a2, done: c });
    }, f);
  }
}
function p(r) {
  return typeof r == "function";
}
function B(r) {
  var e = function(o) {
    Error.call(o), o.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var rr = B(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(o, n) {
      return n + 1 + ") " + o.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function U(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var W = function() {
  function r(e) {
    this.initialTeardown = e, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, o, n, i;
    if (!this.closed) {
      this.closed = true;
      var f = this._parentage;
      if (f)
        if (this._parentage = null, Array.isArray(f))
          try {
            for (var c = I(f), u = c.next(); !u.done; u = c.next()) {
              var a2 = u.value;
              a2.remove(this);
            }
          } catch (x) {
            e = { error: x };
          } finally {
            try {
              u && !u.done && (t = c.return) && t.call(c);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          f.remove(this);
      var m = this.initialTeardown;
      if (p(m))
        try {
          m();
        } catch (x) {
          i = x instanceof rr ? x.errors : [x];
        }
      var h = this._finalizers;
      if (h) {
        this._finalizers = null;
        try {
          for (var l = I(h), y = l.next(); !y.done; y = l.next()) {
            var g = y.value;
            try {
              Ur(g);
            } catch (x) {
              i = i ?? [], x instanceof rr ? i = A(A([], w(i)), w(x.errors)) : i.push(x);
            }
          }
        } catch (x) {
          o = { error: x };
        } finally {
          try {
            y && !y.done && (n = l.return) && n.call(l);
          } finally {
            if (o)
              throw o.error;
          }
        }
      }
      if (i)
        throw new rr(i);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        Ur(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && U(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && U(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = function() {
    var e = new r();
    return e.closed = true, e;
  }(), r;
}();
var vt = W.EMPTY;
function er(r) {
  return r instanceof W || r && "closed" in r && p(r.remove) && p(r.add) && p(r.unsubscribe);
}
function Ur(r) {
  p(r) ? r() : r.unsubscribe();
}
var P = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: false, useDeprecatedNextContext: false };
var D = { setTimeout: function(r, e) {
  for (var t = [], o = 2; o < arguments.length; o++)
    t[o - 2] = arguments[o];
  var n = D.delegate;
  return n != null && n.setTimeout ? n.setTimeout.apply(n, A([r, e], w(t))) : setTimeout.apply(void 0, A([r, e], w(t)));
}, clearTimeout: function(r) {
  var e = D.delegate;
  return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(r);
}, delegate: void 0 };
function tr(r) {
  D.setTimeout(function() {
    var e = P.onUnhandledError;
    if (e)
      e(r);
    else
      throw r;
  });
}
function F() {
}
var Vr = function() {
  return Er("C", void 0, void 0);
}();
function Wr(r) {
  return Er("E", void 0, r);
}
function Dr(r) {
  return Er("N", r, void 0);
}
function Er(r, e, t) {
  return { kind: r, value: e, error: t };
}
var V = null;
function Yr(r) {
  if (P.useDeprecatedSynchronousErrorHandling) {
    var e = !V;
    if (e && (V = { errorThrown: false, error: null }), r(), e) {
      var t = V, o = t.errorThrown, n = t.error;
      if (V = null, o)
        throw n;
    }
  } else
    r();
}
function qr(r) {
  P.useDeprecatedSynchronousErrorHandling && V && (V.errorThrown = true, V.error = r);
}
var K = function(r) {
  T(e, r);
  function e(t) {
    var o = r.call(this) || this;
    return o.isStopped = false, t ? (o.destination = t, er(t) && t.add(o)) : o.destination = Me, o;
  }
  return e.create = function(t, o, n) {
    return new Y(t, o, n);
  }, e.prototype.next = function(t) {
    this.isStopped ? Ar(Dr(t), this) : this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped ? Ar(Wr(t), this) : (this.isStopped = true, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped ? Ar(Vr, this) : (this.isStopped = true, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(W);
var Fe = Function.prototype.bind;
function Or(r, e) {
  return Fe.call(r, e);
}
var je = function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (o) {
        or(o);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (o) {
        or(o);
      }
    else
      or(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        or(t);
      }
  }, r;
}();
var Y = function(r) {
  T(e, r);
  function e(t, o, n) {
    var i = r.call(this) || this, f;
    if (p(t) || !t)
      f = { next: t ?? void 0, error: o ?? void 0, complete: n ?? void 0 };
    else {
      var c;
      i && P.useDeprecatedNextContext ? (c = Object.create(t), c.unsubscribe = function() {
        return i.unsubscribe();
      }, f = { next: t.next && Or(t.next, c), error: t.error && Or(t.error, c), complete: t.complete && Or(t.complete, c) }) : f = t;
    }
    return i.destination = new je(f), i;
  }
  return e;
}(K);
function or(r) {
  P.useDeprecatedSynchronousErrorHandling ? qr(r) : tr(r);
}
function ke(r) {
  throw r;
}
function Ar(r, e) {
  var t = P.onStoppedNotification;
  t && D.setTimeout(function() {
    return t(r, e);
  });
}
var Me = { closed: true, next: F, error: ke, complete: F };
var q = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function S(r) {
  return r;
}
function Nr() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return _r(r);
}
function _r(r) {
  return r.length === 0 ? S : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(o, n) {
      return n(o);
    }, t);
  };
}
var b = function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, o) {
    var n = this, i = Le(e) ? e : new Y(e, t, o);
    return Yr(function() {
      var f = n, c = f.operator, u = f.source;
      i.add(c ? c.call(i, u) : u ? n._subscribe(i) : n._trySubscribe(i));
    }), i;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var o = this;
    return t = Gr(t), new t(function(n, i) {
      var f = new Y({ next: function(c) {
        try {
          e(c);
        } catch (u) {
          i(u), f.unsubscribe();
        }
      }, error: i, complete: n });
      o.subscribe(f);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[q] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return _r(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = Gr(e), new e(function(o, n) {
      var i;
      t.subscribe(function(f) {
        return i = f;
      }, function(f) {
        return n(f);
      }, function() {
        return o(i);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function Gr(r) {
  var e;
  return (e = r ?? P.Promise) !== null && e !== void 0 ? e : Promise;
}
function Re(r) {
  return r && p(r.next) && p(r.error) && p(r.complete);
}
function Le(r) {
  return r && r instanceof K || Re(r) && er(r);
}
function Ce(r) {
  return p(r == null ? void 0 : r.lift);
}
function d(r) {
  return function(e) {
    if (Ce(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (o) {
          this.error(o);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function s(r, e, t, o, n) {
  return new Ue(r, e, t, o, n);
}
var Ue = function(r) {
  T(e, r);
  function e(t, o, n, i, f, c) {
    var u = r.call(this, t) || this;
    return u.onFinalize = f, u.shouldUnsubscribe = c, u._next = o ? function(a2) {
      try {
        o(a2);
      } catch (m) {
        t.error(m);
      }
    } : r.prototype._next, u._error = i ? function(a2) {
      try {
        i(a2);
      } catch (m) {
        t.error(m);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, u._complete = n ? function() {
      try {
        n();
      } catch (a2) {
        t.error(a2);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, u;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var o = this.closed;
      r.prototype.unsubscribe.call(this), !o && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(K);
var Ir = { now: function() {
  return (Ir.delegate || Date).now();
}, delegate: void 0 };
var Hr = function(r) {
  T(e, r);
  function e(t, o) {
    return r.call(this) || this;
  }
  return e.prototype.schedule = function(t, o) {
    return o === void 0 && (o = 0), this;
  }, e;
}(W);
var z = { setInterval: function(r, e) {
  for (var t = [], o = 2; o < arguments.length; o++)
    t[o - 2] = arguments[o];
  var n = z.delegate;
  return n != null && n.setInterval ? n.setInterval.apply(n, A([r, e], w(t))) : setInterval.apply(void 0, A([r, e], w(t)));
}, clearInterval: function(r) {
  var e = z.delegate;
  return ((e == null ? void 0 : e.clearInterval) || clearInterval)(r);
}, delegate: void 0 };
var Jr = function(r) {
  T(e, r);
  function e(t, o) {
    var n = r.call(this, t, o) || this;
    return n.scheduler = t, n.work = o, n.pending = false, n;
  }
  return e.prototype.schedule = function(t, o) {
    var n;
    if (o === void 0 && (o = 0), this.closed)
      return this;
    this.state = t;
    var i = this.id, f = this.scheduler;
    return i != null && (this.id = this.recycleAsyncId(f, i, o)), this.pending = true, this.delay = o, this.id = (n = this.id) !== null && n !== void 0 ? n : this.requestAsyncId(f, this.id, o), this;
  }, e.prototype.requestAsyncId = function(t, o, n) {
    return n === void 0 && (n = 0), z.setInterval(t.flush.bind(t, this), n);
  }, e.prototype.recycleAsyncId = function(t, o, n) {
    if (n === void 0 && (n = 0), n != null && this.delay === n && this.pending === false)
      return o;
    o != null && z.clearInterval(o);
  }, e.prototype.execute = function(t, o) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = false;
    var n = this._execute(t, o);
    if (n)
      return n;
    this.pending === false && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(t, o) {
    var n = false, i;
    try {
      this.work(t);
    } catch (f) {
      n = true, i = f || new Error("Scheduled action threw falsy error");
    }
    if (n)
      return this.unsubscribe(), i;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var t = this, o = t.id, n = t.scheduler, i = n.actions;
      this.work = this.state = this.scheduler = null, this.pending = false, U(i, this), o != null && (this.id = this.recycleAsyncId(n, o, null)), this.delay = null, r.prototype.unsubscribe.call(this);
    }
  }, e;
}(Hr);
var Tr = function() {
  function r(e, t) {
    t === void 0 && (t = r.now), this.schedulerActionCtor = e, this.now = t;
  }
  return r.prototype.schedule = function(e, t, o) {
    return t === void 0 && (t = 0), new this.schedulerActionCtor(this, e).schedule(o, t);
  }, r.now = Ir.now, r;
}();
var Kr = function(r) {
  T(e, r);
  function e(t, o) {
    o === void 0 && (o = Tr.now);
    var n = r.call(this, t, o) || this;
    return n.actions = [], n._active = false, n;
  }
  return e.prototype.flush = function(t) {
    var o = this.actions;
    if (this._active) {
      o.push(t);
      return;
    }
    var n;
    this._active = true;
    do
      if (n = t.execute(t.state, t.delay))
        break;
    while (t = o.shift());
    if (this._active = false, n) {
      for (; t = o.shift(); )
        t.unsubscribe();
      throw n;
    }
  }, e;
}(Tr);
var Pr = new Kr(Jr);
var zr = Pr;
var N = new b(function(r) {
  return r.complete();
});
function nr(r) {
  return r && p(r.schedule);
}
function Fr(r) {
  return r[r.length - 1];
}
function Qr(r) {
  return p(Fr(r)) ? r.pop() : void 0;
}
function R(r) {
  return nr(Fr(r)) ? r.pop() : void 0;
}
function Xr(r, e) {
  return typeof Fr(r) == "number" ? r.pop() : e;
}
var G = function(r) {
  return r && typeof r.length == "number" && typeof r != "function";
};
function ir(r) {
  return p(r == null ? void 0 : r.then);
}
function fr(r) {
  return p(r[q]);
}
function ar(r) {
  return Symbol.asyncIterator && p(r == null ? void 0 : r[Symbol.asyncIterator]);
}
function ur(r) {
  return new TypeError("You provided " + (r !== null && typeof r == "object" ? "an invalid object" : "'" + r + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Ve() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var cr = Ve();
function pr(r) {
  return p(r == null ? void 0 : r[cr]);
}
function mr(r) {
  return Lr(this, arguments, function() {
    var t, o, n, i;
    return $(this, function(f) {
      switch (f.label) {
        case 0:
          t = r.getReader(), f.label = 1;
        case 1:
          f.trys.push([1, , 9, 10]), f.label = 2;
        case 2:
          return [4, C(t.read())];
        case 3:
          return o = f.sent(), n = o.value, i = o.done, i ? [4, C(void 0)] : [3, 5];
        case 4:
          return [2, f.sent()];
        case 5:
          return [4, C(n)];
        case 6:
          return [4, f.sent()];
        case 7:
          return f.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function sr(r) {
  return p(r == null ? void 0 : r.getReader);
}
function v(r) {
  if (r instanceof b)
    return r;
  if (r != null) {
    if (fr(r))
      return We(r);
    if (G(r))
      return De(r);
    if (ir(r))
      return Ye(r);
    if (ar(r))
      return Zr(r);
    if (pr(r))
      return qe(r);
    if (sr(r))
      return Ne(r);
  }
  throw ur(r);
}
function We(r) {
  return new b(function(e) {
    var t = r[q]();
    if (p(t.subscribe))
      return t.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function De(r) {
  return new b(function(e) {
    for (var t = 0; t < r.length && !e.closed; t++)
      e.next(r[t]);
    e.complete();
  });
}
function Ye(r) {
  return new b(function(e) {
    r.then(function(t) {
      e.closed || (e.next(t), e.complete());
    }, function(t) {
      return e.error(t);
    }).then(null, tr);
  });
}
function qe(r) {
  return new b(function(e) {
    var t, o;
    try {
      for (var n = I(r), i = n.next(); !i.done; i = n.next()) {
        var f = i.value;
        if (e.next(f), e.closed)
          return;
      }
    } catch (c) {
      t = { error: c };
    } finally {
      try {
        i && !i.done && (o = n.return) && o.call(n);
      } finally {
        if (t)
          throw t.error;
      }
    }
    e.complete();
  });
}
function Zr(r) {
  return new b(function(e) {
    Ge(r, e).catch(function(t) {
      return e.error(t);
    });
  });
}
function Ne(r) {
  return Zr(mr(r));
}
function Ge(r, e) {
  var t, o, n, i;
  return Rr(this, void 0, void 0, function() {
    var f, c;
    return $(this, function(u) {
      switch (u.label) {
        case 0:
          u.trys.push([0, 5, 6, 11]), t = Cr(r), u.label = 1;
        case 1:
          return [4, t.next()];
        case 2:
          if (o = u.sent(), !!o.done)
            return [3, 4];
          if (f = o.value, e.next(f), e.closed)
            return [2];
          u.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return c = u.sent(), n = { error: c }, [3, 11];
        case 6:
          return u.trys.push([6, , 9, 10]), o && !o.done && (i = t.return) ? [4, i.call(t)] : [3, 8];
        case 7:
          u.sent(), u.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (n)
            throw n.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function _(r, e, t, o, n) {
  o === void 0 && (o = 0), n === void 0 && (n = false);
  var i = e.schedule(function() {
    t(), n ? r.add(this.schedule(null, o)) : this.unsubscribe();
  }, o);
  if (r.add(i), !n)
    return i;
}
function lr(r, e) {
  return e === void 0 && (e = 0), d(function(t, o) {
    t.subscribe(s(o, function(n) {
      return _(o, r, function() {
        return o.next(n);
      }, e);
    }, function() {
      return _(o, r, function() {
        return o.complete();
      }, e);
    }, function(n) {
      return _(o, r, function() {
        return o.error(n);
      }, e);
    }));
  });
}
function dr(r, e) {
  return e === void 0 && (e = 0), d(function(t, o) {
    o.add(r.schedule(function() {
      return t.subscribe(o);
    }, e));
  });
}
function $r(r, e) {
  return v(r).pipe(dr(e), lr(e));
}
function Br(r, e) {
  return v(r).pipe(dr(e), lr(e));
}
function re(r, e) {
  return new b(function(t) {
    var o = 0;
    return e.schedule(function() {
      o === r.length ? t.complete() : (t.next(r[o++]), t.closed || this.schedule());
    });
  });
}
function ee(r, e) {
  return new b(function(t) {
    var o;
    return _(t, e, function() {
      o = r[cr](), _(t, e, function() {
        var n, i, f;
        try {
          n = o.next(), i = n.value, f = n.done;
        } catch (c) {
          t.error(c);
          return;
        }
        f ? t.complete() : t.next(i);
      }, 0, true);
    }), function() {
      return p(o == null ? void 0 : o.return) && o.return();
    };
  });
}
function hr(r, e) {
  if (!r)
    throw new Error("Iterable cannot be null");
  return new b(function(t) {
    _(t, e, function() {
      var o = r[Symbol.asyncIterator]();
      _(t, e, function() {
        o.next().then(function(n) {
          n.done ? t.complete() : t.next(n.value);
        });
      }, 0, true);
    });
  });
}
function te(r, e) {
  return hr(mr(r), e);
}
function oe(r, e) {
  if (r != null) {
    if (fr(r))
      return $r(r, e);
    if (G(r))
      return re(r, e);
    if (ir(r))
      return Br(r, e);
    if (ar(r))
      return hr(r, e);
    if (pr(r))
      return ee(r, e);
    if (sr(r))
      return te(r, e);
  }
  throw ur(r);
}
function j(r, e) {
  return e ? oe(r, e) : v(r);
}
function ne() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = R(r);
  return j(r, t);
}
var L = B(function(r) {
  return function() {
    r(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function ie(r, e) {
  var t = typeof e == "object";
  return new Promise(function(o, n) {
    var i = false, f;
    r.subscribe({ next: function(c) {
      f = c, i = true;
    }, error: n, complete: function() {
      i ? o(f) : t ? o(e.defaultValue) : n(new L());
    } });
  });
}
function fe(r, e) {
  var t = typeof e == "object";
  return new Promise(function(o, n) {
    var i = new Y({ next: function(f) {
      o(f), i.unsubscribe();
    }, error: n, complete: function() {
      t ? o(e.defaultValue) : n(new L());
    } });
    r.subscribe(i);
  });
}
function ae(r) {
  return r instanceof Date && !isNaN(r);
}
function k(r, e) {
  return d(function(t, o) {
    var n = 0;
    t.subscribe(s(o, function(i) {
      o.next(r.call(e, i, n++));
    }));
  });
}
var He = Array.isArray;
function Je(r, e) {
  return He(e) ? r.apply(void 0, A([], w(e))) : r(e);
}
function vr(r) {
  return k(function(e) {
    return Je(r, e);
  });
}
var Ke = Array.isArray;
var ze = Object.getPrototypeOf;
var Qe = Object.prototype;
var Xe = Object.keys;
function ue(r) {
  if (r.length === 1) {
    var e = r[0];
    if (Ke(e))
      return { args: e, keys: null };
    if (Ze(e)) {
      var t = Xe(e);
      return { args: t.map(function(o) {
        return e[o];
      }), keys: t };
    }
  }
  return { args: r, keys: null };
}
function Ze(r) {
  return r && typeof r == "object" && ze(r) === Qe;
}
function ce(r, e) {
  return r.reduce(function(t, o, n) {
    return t[o] = e[n], t;
  }, {});
}
function pe(r, e, t, o, n, i, f, c) {
  var u = [], a2 = 0, m = 0, h = false, l = function() {
    h && !u.length && !a2 && e.complete();
  }, y = function(x) {
    return a2 < o ? g(x) : u.push(x);
  }, g = function(x) {
    i && e.next(x), a2++;
    var O = false;
    v(t(x, m++)).subscribe(s(e, function(M) {
      n == null || n(M), i ? y(M) : e.next(M);
    }, function() {
      O = true;
    }, void 0, function() {
      if (O)
        try {
          a2--;
          for (var M = function() {
            var Z = u.shift();
            f ? _(e, f, function() {
              return g(Z);
            }) : g(Z);
          }; u.length && a2 < o; )
            M();
          l();
        } catch (Z) {
          e.error(Z);
        }
    }));
  };
  return r.subscribe(s(e, y, function() {
    h = true, l();
  })), function() {
    c == null || c();
  };
}
function E(r, e, t) {
  return t === void 0 && (t = 1 / 0), p(e) ? E(function(o, n) {
    return k(function(i, f) {
      return e(o, i, n, f);
    })(v(r(o, n)));
  }, t) : (typeof e == "number" && (t = e), d(function(o, n) {
    return pe(o, n, r, t);
  }));
}
function yr(r) {
  return r === void 0 && (r = 1 / 0), E(S, r);
}
function me() {
  return yr(1);
}
function Q() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return me()(j(r, R(r)));
}
function se(r) {
  return new b(function(e) {
    v(r()).subscribe(e);
  });
}
function le() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Qr(r), o = ue(r), n = o.args, i = o.keys, f = new b(function(c) {
    var u = n.length;
    if (!u) {
      c.complete();
      return;
    }
    for (var a2 = new Array(u), m = u, h = u, l = function(g) {
      var x = false;
      v(n[g]).subscribe(s(c, function(O) {
        x || (x = true, h--), a2[g] = O;
      }, function() {
        return m--;
      }, void 0, function() {
        (!m || !x) && (h || c.next(i ? ce(i, a2) : a2), c.complete());
      }));
    }, y = 0; y < u; y++)
      l(y);
  });
  return t ? f.pipe(vr(t)) : f;
}
var $e = ["addListener", "removeListener"];
var Be = ["addEventListener", "removeEventListener"];
var rt = ["on", "off"];
function xr(r, e, t, o) {
  if (p(t) && (o = t, t = void 0), o)
    return xr(r, e, t).pipe(vr(o));
  var n = w(ot(r) ? Be.map(function(c) {
    return function(u) {
      return r[c](e, u, t);
    };
  }) : et(r) ? $e.map(de(r, e)) : tt(r) ? rt.map(de(r, e)) : [], 2), i = n[0], f = n[1];
  if (!i && G(r))
    return E(function(c) {
      return xr(c, e, t);
    })(v(r));
  if (!i)
    throw new TypeError("Invalid event target");
  return new b(function(c) {
    var u = function() {
      for (var a2 = [], m = 0; m < arguments.length; m++)
        a2[m] = arguments[m];
      return c.next(1 < a2.length ? a2 : a2[0]);
    };
    return i(u), function() {
      return f(u);
    };
  });
}
function de(r, e) {
  return function(t) {
    return function(o) {
      return r[t](e, o);
    };
  };
}
function et(r) {
  return p(r.addListener) && p(r.removeListener);
}
function tt(r) {
  return p(r.on) && p(r.off);
}
function ot(r) {
  return p(r.addEventListener) && p(r.removeEventListener);
}
function H(r, e, t) {
  r === void 0 && (r = 0), t === void 0 && (t = zr);
  var o = -1;
  return e != null && (nr(e) ? t = e : o = e), new b(function(n) {
    var i = ae(r) ? +r - t.now() : r;
    i < 0 && (i = 0);
    var f = 0;
    return t.schedule(function() {
      n.closed || (n.next(f++), 0 <= o ? this.schedule(void 0, o) : n.complete());
    }, i);
  });
}
function he() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = R(r), o = Xr(r, 1 / 0), n = r;
  return n.length ? n.length === 1 ? v(n[0]) : yr(o)(j(n, t)) : N;
}
var ve = new b(F);
var nt = Array.isArray;
function ye(r) {
  return r.length === 1 && nt(r[0]) ? r[0] : r;
}
function J(r, e) {
  return d(function(t, o) {
    var n = 0;
    t.subscribe(s(o, function(i) {
      return r.call(e, i, n++) && o.next(i);
    }));
  });
}
function xe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return r = ye(r), r.length === 1 ? v(r[0]) : new b(jr(r));
}
function jr(r) {
  return function(e) {
    for (var t = [], o = function(i) {
      t.push(v(r[i]).subscribe(s(e, function(f) {
        if (t) {
          for (var c = 0; c < t.length; c++)
            c !== i && t[c].unsubscribe();
          t = null;
        }
        e.next(f);
      })));
    }, n = 0; t && !e.closed && n < r.length; n++)
      o(n);
  };
}
function be(r, e) {
  return e === void 0 && (e = null), e = e ?? r, d(function(t, o) {
    var n = [], i = 0;
    t.subscribe(s(o, function(f) {
      var c, u, a2, m, h = null;
      i++ % e === 0 && n.push([]);
      try {
        for (var l = I(n), y = l.next(); !y.done; y = l.next()) {
          var g = y.value;
          g.push(f), r <= g.length && (h = h ?? [], h.push(g));
        }
      } catch (M) {
        c = { error: M };
      } finally {
        try {
          y && !y.done && (u = l.return) && u.call(l);
        } finally {
          if (c)
            throw c.error;
        }
      }
      if (h)
        try {
          for (var x = I(h), O = x.next(); !O.done; O = x.next()) {
            var g = O.value;
            U(n, g), o.next(g);
          }
        } catch (M) {
          a2 = { error: M };
        } finally {
          try {
            O && !O.done && (m = x.return) && m.call(x);
          } finally {
            if (a2)
              throw a2.error;
          }
        }
    }, function() {
      var f, c;
      try {
        for (var u = I(n), a2 = u.next(); !a2.done; a2 = u.next()) {
          var m = a2.value;
          o.next(m);
        }
      } catch (h) {
        f = { error: h };
      } finally {
        try {
          a2 && !a2.done && (c = u.return) && c.call(u);
        } finally {
          if (f)
            throw f.error;
        }
      }
      o.complete();
    }, void 0, function() {
      n = null;
    }));
  });
}
function kr(r) {
  return d(function(e, t) {
    var o = null, n = false, i;
    o = e.subscribe(s(t, void 0, void 0, function(f) {
      i = v(r(f, kr(r)(e))), o ? (o.unsubscribe(), o = null, i.subscribe(t)) : n = true;
    })), n && (o.unsubscribe(), o = null, i.subscribe(t));
  });
}
function ge(r, e) {
  return p(e) ? E(r, e, 1) : E(r, 1);
}
function br(r) {
  return d(function(e, t) {
    var o = false;
    e.subscribe(s(t, function(n) {
      o = true, t.next(n);
    }, function() {
      o || t.next(r), t.complete();
    }));
  });
}
function X(r) {
  return r <= 0 ? function() {
    return N;
  } : d(function(e, t) {
    var o = 0;
    e.subscribe(s(t, function(n) {
      ++o <= r && (t.next(n), r <= o && t.complete());
    }));
  });
}
function gr() {
  return d(function(r, e) {
    r.subscribe(s(e, F));
  });
}
function we(r) {
  return k(function() {
    return r;
  });
}
function Mr(r, e) {
  return e ? function(t) {
    return Q(e.pipe(X(1), gr()), t.pipe(Mr(r)));
  } : E(function(t, o) {
    return v(r(t, o)).pipe(X(1), we(t));
  });
}
function Se(r, e) {
  e === void 0 && (e = Pr);
  var t = H(r, e);
  return Mr(function() {
    return t;
  });
}
function wr(r) {
  return r === void 0 && (r = it), d(function(e, t) {
    var o = false;
    e.subscribe(s(t, function(n) {
      o = true, t.next(n);
    }, function() {
      return o ? t.complete() : t.error(r());
    }));
  });
}
function it() {
  return new L();
}
function Ee(r, e) {
  var t = arguments.length >= 2;
  return function(o) {
    return o.pipe(r ? J(function(n, i) {
      return r(n, i, o);
    }) : S, X(1), t ? br(e) : wr(function() {
      return new L();
    }));
  };
}
function Oe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return r.length ? d(function(t, o) {
    jr(A([t], w(r)))(o);
  }) : S;
}
function Ae(r) {
  r === void 0 && (r = 1 / 0);
  var e;
  r && typeof r == "object" ? e = r : e = { count: r };
  var t = e.count, o = t === void 0 ? 1 / 0 : t, n = e.delay, i = e.resetOnSuccess, f = i === void 0 ? false : i;
  return o <= 0 ? S : d(function(c, u) {
    var a2 = 0, m, h = function() {
      var l = false;
      m = c.subscribe(s(u, function(y) {
        f && (a2 = 0), u.next(y);
      }, void 0, function(y) {
        if (a2++ < o) {
          var g = function() {
            m ? (m.unsubscribe(), m = null, h()) : l = true;
          };
          if (n != null) {
            var x = typeof n == "number" ? H(n) : v(n(y, a2)), O = s(u, function() {
              O.unsubscribe(), g();
            }, function() {
              u.complete();
            });
            x.subscribe(O);
          } else
            g();
        } else
          u.error(y);
      })), l && (m.unsubscribe(), m = null, h());
    };
    h();
  });
}
function _e() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = R(r);
  return d(function(o, n) {
    (t ? Q(r, o, t) : Q(r, o)).subscribe(n);
  });
}
function Ie(r, e) {
  return d(function(t, o) {
    var n = null, i = 0, f = false, c = function() {
      return f && !n && o.complete();
    };
    t.subscribe(s(o, function(u) {
      n == null || n.unsubscribe();
      var a2 = 0, m = i++;
      v(r(u, m)).subscribe(n = s(o, function(h) {
        return o.next(e ? e(u, h, m, a2++) : h);
      }, function() {
        n = null, c();
      }));
    }, function() {
      f = true, c();
    }));
  });
}
function Te(r) {
  return d(function(e, t) {
    v(r).subscribe(s(t, function() {
      return t.complete();
    }, F)), !t.closed && e.subscribe(t);
  });
}
function Pe(r, e, t) {
  var o = p(r) || e || t ? { next: r, error: e, complete: t } : r;
  return o ? d(function(n, i) {
    var f;
    (f = o.subscribe) === null || f === void 0 || f.call(o);
    var c = true;
    n.subscribe(s(i, function(u) {
      var a2;
      (a2 = o.next) === null || a2 === void 0 || a2.call(o, u), i.next(u);
    }, function() {
      var u;
      c = false, (u = o.complete) === null || u === void 0 || u.call(o), i.complete();
    }, function(u) {
      var a2;
      c = false, (a2 = o.error) === null || a2 === void 0 || a2.call(o, u), i.error(u);
    }, function() {
      var u, a2;
      c && ((u = o.unsubscribe) === null || u === void 0 || u.call(o)), (a2 = o.finalize) === null || a2 === void 0 || a2.call(o);
    }));
  }) : S;
}
function Au(r) {
  return E((e) => j(Promise.resolve(r(e))).pipe(J((t) => t), k(() => e)));
}

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js
Symbol.dispose ?? (Symbol.dispose = Symbol("dispose"));
Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol("asyncDispose"));
var disposeSymbol = Symbol.dispose;
var asyncDisposeSymbol = Symbol.asyncDispose;
var _disposed, _stack, _a, _b;
var _DisposableStack = class _DisposableStack {
  constructor() {
    __privateAdd(this, _disposed, false);
    __privateAdd(this, _stack, []);
    __publicField(this, _a, this.dispose);
    __publicField(this, _b, "DisposableStack");
  }
  /**
   * Returns a value indicating whether this stack has been disposed.
   */
  get disposed() {
    return __privateGet(this, _disposed);
  }
  /**
   * Disposes each resource in the stack in the reverse order that they were added.
   */
  dispose() {
    if (__privateGet(this, _disposed)) {
      return;
    }
    __privateSet(this, _disposed, true);
    for (const resource of __privateGet(this, _stack).reverse()) {
      resource[disposeSymbol]();
    }
  }
  /**
   * Adds a disposable resource to the stack, returning the resource.
   *
   * @param value - The resource to add. `null` and `undefined` will not be added,
   * but will be returned.
   * @returns The provided `value`.
   */
  use(value) {
    if (value) {
      __privateGet(this, _stack).push(value);
    }
    return value;
  }
  /**
   * Adds a value and associated disposal callback as a resource to the stack.
   *
   * @param value - The value to add.
   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
   * method. Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(value, onDispose) {
    __privateGet(this, _stack).push({
      [disposeSymbol]() {
        onDispose(value);
      }
    });
    return value;
  }
  /**
   * Adds a callback to be invoked when the stack is disposed.
   */
  defer(onDispose) {
    __privateGet(this, _stack).push({
      [disposeSymbol]() {
        onDispose();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (__privateGet(this, _disposed)) {
      throw new ReferenceError("a disposed stack can not use anything new");
    }
    const stack = new _DisposableStack();
    __privateSet(stack, _stack, __privateGet(this, _stack));
    __privateSet(this, _disposed, true);
    return stack;
  }
};
_a = disposeSymbol, _b = Symbol.toStringTag;
_disposed = new WeakMap();
_stack = new WeakMap();
var DisposableStack = _DisposableStack;
var _disposed2, _stack2, _a2, _b2;
var _AsyncDisposableStack = class _AsyncDisposableStack {
  constructor() {
    __privateAdd(this, _disposed2, false);
    __privateAdd(this, _stack2, []);
    __publicField(this, _a2, this.dispose);
    __publicField(this, _b2, "AsyncDisposableStack");
  }
  /**
   * Returns a value indicating whether this stack has been disposed.
   */
  get disposed() {
    return __privateGet(this, _disposed2);
  }
  /**
   * Disposes each resource in the stack in the reverse order that they were added.
   */
  async dispose() {
    if (__privateGet(this, _disposed2)) {
      return;
    }
    __privateSet(this, _disposed2, true);
    for (const resource of __privateGet(this, _stack2).reverse()) {
      await resource[asyncDisposeSymbol]();
    }
  }
  /**
   * Adds a disposable resource to the stack, returning the resource.
   *
   * @param value - The resource to add. `null` and `undefined` will not be added,
   * but will be returned.
   * @returns The provided `value`.
   */
  use(value) {
    if (value) {
      __privateGet(this, _stack2).push(value);
    }
    return value;
  }
  /**
   * Adds a value and associated disposal callback as a resource to the stack.
   *
   * @param value - The value to add.
   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
   * method. Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(value, onDispose) {
    __privateGet(this, _stack2).push({
      [asyncDisposeSymbol]() {
        return onDispose(value);
      }
    });
    return value;
  }
  /**
   * Adds a callback to be invoked when the stack is disposed.
   */
  defer(onDispose) {
    __privateGet(this, _stack2).push({
      [asyncDisposeSymbol]() {
        return onDispose();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (__privateGet(this, _disposed2)) {
      throw new ReferenceError("a disposed stack can not use anything new");
    }
    const stack = new _AsyncDisposableStack();
    __privateSet(stack, _stack2, __privateGet(this, _stack2));
    __privateSet(this, _disposed2, true);
    return stack;
  }
};
_a2 = asyncDisposeSymbol, _b2 = Symbol.toStringTag;
_disposed2 = new WeakMap();
_stack2 = new WeakMap();
var AsyncDisposableStack = _AsyncDisposableStack;

// ../../../node_modules/puppeteer-core/lib/esm/third_party/mitt/mitt.js
function a(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(f, i) {
    var t = e.get(f);
    t ? t.push(i) : e.set(f, [i]);
  }, off: function(f, i) {
    var t = e.get(f);
    t && (i ? t.splice(t.indexOf(i) >>> 0, 1) : e.set(f, []));
  }, emit: function(f, i) {
    var t = e.get(f);
    t && t.slice().map(function(o) {
      o(i);
    }), (t = e.get("*")) && t.slice().map(function(o) {
      o(f, i);
    });
  } };
}

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js
var _emitter, _handlers;
var EventEmitter = class {
  /**
   * @internal
   */
  constructor() {
    __privateAdd(this, _emitter, void 0);
    __privateAdd(this, _handlers, /* @__PURE__ */ new Map());
    __privateSet(this, _emitter, a(__privateGet(this, _handlers)));
  }
  /**
   * Bind an event listener to fire when an event occurs.
   * @param type - the event type you'd like to listen to. Can be a string or symbol.
   * @param handler - the function to be called when the event occurs.
   * @returns `this` to enable you to chain method calls.
   */
  on(type, handler) {
    __privateGet(this, _emitter).on(type, handler);
    return this;
  }
  /**
   * Remove an event listener from firing.
   * @param type - the event type you'd like to stop listening to.
   * @param handler - the function that should be removed.
   * @returns `this` to enable you to chain method calls.
   */
  off(type, handler) {
    __privateGet(this, _emitter).off(type, handler);
    return this;
  }
  /**
   * Remove an event listener.
   *
   * @deprecated please use {@link EventEmitter.off} instead.
   */
  removeListener(type, handler) {
    this.off(type, handler);
    return this;
  }
  /**
   * Add an event listener.
   *
   * @deprecated please use {@link EventEmitter.on} instead.
   */
  addListener(type, handler) {
    this.on(type, handler);
    return this;
  }
  /**
   * Emit an event and call any associated listeners.
   *
   * @param type - the event you'd like to emit
   * @param eventData - any data you'd like to emit with the event
   * @returns `true` if there are any listeners, `false` if there are not.
   */
  emit(type, event) {
    __privateGet(this, _emitter).emit(type, event);
    return this.listenerCount(type) > 0;
  }
  /**
   * Like `on` but the listener will only be fired once and then it will be removed.
   * @param type - the event you'd like to listen to
   * @param handler - the handler function to run when the event occurs
   * @returns `this` to enable you to chain method calls.
   */
  once(type, handler) {
    const onceHandler = (eventData) => {
      handler(eventData);
      this.off(type, onceHandler);
    };
    return this.on(type, onceHandler);
  }
  /**
   * Gets the number of listeners for a given event.
   *
   * @param type - the event to get the listener count for
   * @returns the number of listeners bound to the given event
   */
  listenerCount(type) {
    var _a4;
    return ((_a4 = __privateGet(this, _handlers).get(type)) == null ? void 0 : _a4.length) || 0;
  }
  /**
   * Removes all listeners. If given an event argument, it will remove only
   * listeners for that event.
   *
   * @param type - the event to remove listeners for.
   * @returns `this` to enable you to chain method calls.
   */
  removeAllListeners(type) {
    if (type === void 0 || type === "*") {
      __privateGet(this, _handlers).clear();
    } else {
      __privateGet(this, _handlers).delete(type);
    }
    return this;
  }
};
_emitter = new WeakMap();
_handlers = new WeakMap();
var _target, _type, _handler;
var EventSubscription = class {
  constructor(target, type, handler) {
    __privateAdd(this, _target, void 0);
    __privateAdd(this, _type, void 0);
    __privateAdd(this, _handler, void 0);
    __privateSet(this, _target, target);
    __privateSet(this, _type, type);
    __privateSet(this, _handler, handler);
    __privateGet(this, _target).on(__privateGet(this, _type), __privateGet(this, _handler));
  }
  [disposeSymbol]() {
    __privateGet(this, _target).off(__privateGet(this, _type), __privateGet(this, _handler));
  }
};
_target = new WeakMap();
_type = new WeakMap();
_handler = new WeakMap();

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js
var assert = (value, message) => {
  if (!value) {
    throw new Error(message);
  }
};

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
}
function isErrnoException(obj) {
  return isErrorLike(obj) && ("errno" in obj || "code" in obj || "path" in obj || "syscall" in obj);
}
function rewriteError(error, message, originalMessage) {
  error.message = message;
  error.originalMessage = originalMessage ?? error.originalMessage;
  return error;
}
function createProtocolErrorMessage(object) {
  let message = object.error.message;
  if (object.error && typeof object.error === "object" && "data" in object.error) {
    message += ` ${object.error.data}`;
  }
  return message;
}

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/environment.js
var isNode = !!(typeof process !== "undefined" && process.version);
var DEFERRED_PROMISE_DEBUG_TIMEOUT = typeof process !== "undefined" && typeof process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"] !== "undefined" ? Number(process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"]) : -1;

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js
var debugModule = null;
async function importDebug() {
  if (!debugModule) {
    debugModule = (await import("./browser-TRKHCRBW.js")).default;
  }
  return debugModule;
}
var debug = (prefix) => {
  if (isNode) {
    return async (...logArgs) => {
      if (captureLogs) {
        capturedLogs.push(prefix + logArgs);
      }
      (await importDebug())(prefix)(logArgs);
    };
  }
  return (...logArgs) => {
    const debugLevel = globalThis.__PUPPETEER_DEBUG;
    if (!debugLevel) {
      return;
    }
    const everythingShouldBeLogged = debugLevel === "*";
    const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
     * If the debug level is `foo*`, that means we match any prefix that
     * starts with `foo`. If the level is `foo`, we match only the prefix
     * `foo`.
     */
    (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
    if (!prefixMatchesDebugLevel) {
      return;
    }
    console.log(`${prefix}:`, ...logArgs);
  };
};
var capturedLogs = [];
var captureLogs = false;
function setLogCapture(value) {
  capturedLogs = [];
  captureLogs = value;
}
function getCapturedLogs() {
  return capturedLogs;
}

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js
var CustomError = class extends Error {
  /**
   * @internal
   */
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
  /**
   * @internal
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};
var TimeoutError = class extends CustomError {
};
var _code, _originalMessage;
var ProtocolError = class extends CustomError {
  constructor() {
    super(...arguments);
    __privateAdd(this, _code, void 0);
    __privateAdd(this, _originalMessage, "");
  }
  set code(code) {
    __privateSet(this, _code, code);
  }
  /**
   * @readonly
   * @public
   */
  get code() {
    return __privateGet(this, _code);
  }
  set originalMessage(originalMessage) {
    __privateSet(this, _originalMessage, originalMessage);
  }
  /**
   * @readonly
   * @public
   */
  get originalMessage() {
    return __privateGet(this, _originalMessage);
  }
};
_code = new WeakMap();
_originalMessage = new WeakMap();
var UnsupportedOperation = class extends CustomError {
};
var TargetCloseError = class extends ProtocolError {
};
var errors = Object.freeze({
  TimeoutError,
  ProtocolError
});

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js
var debugError = debug("puppeteer:error");
var DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
function createEvaluationError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const messageHeight = message.split("\n").length;
  const error = new Error(message);
  error.name = name;
  const stackLines = error.stack.split("\n");
  const messageLines = stackLines.splice(0, messageHeight);
  stackLines.shift();
  if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
    for (const frame of details.stackTrace.callFrames.reverse()) {
      if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
        const url = PuppeteerURL.parse(frame.url);
        stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
      } else {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
      }
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
function createClientError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const error = new Error(message);
  error.name = name;
  const messageHeight = error.message.split("\n").length;
  const messageLines = error.stack.split("\n").splice(0, messageHeight);
  const stackLines = [];
  if (details.stackTrace) {
    for (const frame of details.stackTrace.callFrames) {
      stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
var getErrorDetails = (details) => {
  var _a4, _b3, _c, _d;
  let name = "";
  let message;
  const lines = ((_b3 = (_a4 = details.exception) == null ? void 0 : _a4.description) == null ? void 0 : _b3.split("\n    at ")) ?? [];
  const size = Math.min(((_c = details.stackTrace) == null ? void 0 : _c.callFrames.length) ?? 0, lines.length - 1);
  lines.splice(-size, size);
  if ((_d = details.exception) == null ? void 0 : _d.className) {
    name = details.exception.className;
  }
  message = lines.join("\n");
  if (name && message.startsWith(`${name}: `)) {
    message = message.slice(name.length + 2);
  }
  return { message, name };
};
var SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
var _functionName, _siteString;
var _PuppeteerURL = class _PuppeteerURL {
  constructor() {
    __privateAdd(this, _functionName, void 0);
    __privateAdd(this, _siteString, void 0);
  }
  static fromCallSite(functionName, site) {
    const url = new _PuppeteerURL();
    __privateSet(url, _functionName, functionName);
    __privateSet(url, _siteString, site.toString());
    return url;
  }
  get functionName() {
    return __privateGet(this, _functionName);
  }
  get siteString() {
    return __privateGet(this, _siteString);
  }
  toString() {
    return `pptr:${[
      __privateGet(this, _functionName),
      encodeURIComponent(__privateGet(this, _siteString))
    ].join(";")}`;
  }
};
_functionName = new WeakMap();
_siteString = new WeakMap();
__publicField(_PuppeteerURL, "INTERNAL_URL", "pptr:internal");
__publicField(_PuppeteerURL, "parse", (url) => {
  url = url.slice("pptr:".length);
  const [functionName = "", siteString = ""] = url.split(";");
  const puppeteerUrl = new _PuppeteerURL();
  __privateSet(puppeteerUrl, _functionName, functionName);
  __privateSet(puppeteerUrl, _siteString, decodeURIComponent(siteString));
  return puppeteerUrl;
});
__publicField(_PuppeteerURL, "isPuppeteerURL", (url) => {
  return url.startsWith("pptr:");
});
var PuppeteerURL = _PuppeteerURL;
var withSourcePuppeteerURLIfNone = (functionName, object) => {
  if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
    return object;
  }
  const original = Error.prepareStackTrace;
  Error.prepareStackTrace = (_2, stack) => {
    return stack[2];
  };
  const site = new Error().stack;
  Error.prepareStackTrace = original;
  return Object.assign(object, {
    [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
  });
};
var getSourcePuppeteerURLIfAvailable = (object) => {
  if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
    return object[SOURCE_URL];
  }
  return void 0;
};
function valueFromRemoteObject(remoteObject) {
  assert(!remoteObject.objectId, "Cannot extract value when objectId is given");
  if (remoteObject.unserializableValue) {
    if (remoteObject.type === "bigint") {
      return BigInt(remoteObject.unserializableValue.replace("n", ""));
    }
    switch (remoteObject.unserializableValue) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
    }
  }
  return remoteObject.value;
}
var isString = (obj) => {
  return typeof obj === "string" || obj instanceof String;
};
var isNumber = (obj) => {
  return typeof obj === "number" || obj instanceof Number;
};
var isPlainObject = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Object;
};
var isRegExp = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === RegExp;
};
var isDate = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Date;
};
function evaluationString(fun, ...args) {
  if (isString(fun)) {
    assert(args.length === 0, "Cannot evaluate a string with arguments");
    return fun;
  }
  function serializeArgument(arg) {
    if (Object.is(arg, void 0)) {
      return "undefined";
    }
    return JSON.stringify(arg);
  }
  return `(${fun})(${args.map(serializeArgument).join(",")})`;
}
function addPageBinding(type, name) {
  const callCdp = globalThis[name];
  if (callCdp[Symbol.toStringTag] === "PuppeteerBinding") {
    return;
  }
  Object.assign(globalThis, {
    [name](...args) {
      const callPuppeteer = globalThis[name];
      callPuppeteer.args ?? (callPuppeteer.args = /* @__PURE__ */ new Map());
      callPuppeteer.callbacks ?? (callPuppeteer.callbacks = /* @__PURE__ */ new Map());
      const seq = (callPuppeteer.lastSeq ?? 0) + 1;
      callPuppeteer.lastSeq = seq;
      callPuppeteer.args.set(seq, args);
      callCdp(JSON.stringify({
        type,
        name,
        seq,
        args,
        isTrivial: !args.some((value) => {
          return value instanceof Node;
        })
      }));
      return new Promise((resolve, reject) => {
        callPuppeteer.callbacks.set(seq, {
          resolve(value) {
            callPuppeteer.args.delete(seq);
            resolve(value);
          },
          reject(value) {
            callPuppeteer.args.delete(seq);
            reject(value);
          }
        });
      });
    }
  });
  globalThis[name][Symbol.toStringTag] = "PuppeteerBinding";
}
function pageBindingInitString(type, name) {
  return evaluationString(addPageBinding, type, name);
}
var fs = null;
async function importFSPromises() {
  if (!fs) {
    try {
      fs = await import("./promises-TO4GPHYO.js");
    } catch (error) {
      if (error instanceof TypeError) {
        throw new Error("Cannot write to a path outside of a Node-like environment.");
      }
      throw error;
    }
  }
  return fs;
}
async function getReadableAsBuffer(readable, path) {
  const buffers = [];
  if (path) {
    const fs2 = await importFSPromises();
    const fileHandle = await fs2.open(path, "w+");
    try {
      for await (const chunk of readable) {
        buffers.push(chunk);
        await fileHandle.writeFile(chunk);
      }
    } finally {
      await fileHandle.close();
    }
  } else {
    for await (const chunk of readable) {
      buffers.push(chunk);
    }
  }
  try {
    return Buffer.concat(buffers);
  } catch (error) {
    return null;
  }
}
async function getReadableFromProtocolStream(client, handle) {
  if (!isNode) {
    throw new Error("Cannot create a stream outside of Node.js environment.");
  }
  const { Readable } = await import("./stream-4EJ2JNUI.js");
  let eof = false;
  return new Readable({
    async read(size) {
      if (eof) {
        return;
      }
      try {
        const response = await client.send("IO.read", { handle, size });
        this.push(response.data, response.base64Encoded ? "base64" : void 0);
        if (response.eof) {
          eof = true;
          await client.send("IO.close", { handle });
          this.push(null);
        }
      } catch (error) {
        if (isErrorLike(error)) {
          this.destroy(error);
          return;
        }
        throw error;
      }
    }
  });
}
function getPageContent() {
  let content = "";
  for (const node of document.childNodes) {
    switch (node) {
      case document.documentElement:
        content += document.documentElement.outerHTML;
        break;
      default:
        content += new XMLSerializer().serializeToString(node);
        break;
    }
  }
  return content;
}
function validateDialogType(type) {
  let dialogType = null;
  const validDialogTypes = /* @__PURE__ */ new Set([
    "alert",
    "confirm",
    "prompt",
    "beforeunload"
  ]);
  if (validDialogTypes.has(type)) {
    dialogType = type;
  }
  assert(dialogType, `Unknown javascript dialog type: ${type}`);
  return dialogType;
}
function timeout(ms) {
  return ms === 0 ? ve : H(ms).pipe(k(() => {
    throw new TimeoutError(`Timed out after waiting ${ms}ms`);
  }));
}
var UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
var SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
function getSourceUrlComment(url) {
  return `//# sourceURL=${url}`;
}
async function waitForHTTP(networkManager, eventName, urlOrPredicate, ms, cancelation) {
  return await fe(xr(networkManager, eventName).pipe(Au(async (http) => {
    if (isString(urlOrPredicate)) {
      return urlOrPredicate === http.url();
    }
    if (typeof urlOrPredicate === "function") {
      return !!await urlOrPredicate(http);
    }
    return false;
  }), Oe(timeout(ms), j(cancelation.valueOrThrow()))));
}
var NETWORK_IDLE_TIME = 500;

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js
var CDPSessionEvent;
(function(CDPSessionEvent2) {
  CDPSessionEvent2.Disconnected = Symbol("CDPSession.Disconnected");
  CDPSessionEvent2.Swapped = Symbol("CDPSession.Swapped");
  CDPSessionEvent2.Ready = Symbol("CDPSession.Ready");
  CDPSessionEvent2.SessionAttached = "sessionattached";
  CDPSessionEvent2.SessionDetached = "sessiondetached";
})(CDPSessionEvent || (CDPSessionEvent = {}));
var CDPSession = class extends EventEmitter {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Parent session in terms of CDP's auto-attach mechanism.
   *
   * @internal
   */
  parentSession() {
    return void 0;
  }
};

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js
var _isResolved, _isRejected, _value, _resolver, _taskPromise, _timeoutId, _timeoutError, _finish, finish_fn;
var _Deferred = class _Deferred {
  constructor(opts) {
    __privateAdd(this, _finish);
    __privateAdd(this, _isResolved, false);
    __privateAdd(this, _isRejected, false);
    __privateAdd(this, _value, void 0);
    __privateAdd(this, _resolver, () => {
    });
    __privateAdd(this, _taskPromise, new Promise((resolve) => {
      __privateSet(this, _resolver, resolve);
    }));
    __privateAdd(this, _timeoutId, void 0);
    __privateAdd(this, _timeoutError, void 0);
    if (opts && opts.timeout > 0) {
      __privateSet(this, _timeoutError, new TimeoutError(opts.message));
      __privateSet(this, _timeoutId, setTimeout(() => {
        this.reject(__privateGet(this, _timeoutError));
      }, opts.timeout));
    }
  }
  resolve(value) {
    if (__privateGet(this, _isRejected) || __privateGet(this, _isResolved)) {
      return;
    }
    __privateSet(this, _isResolved, true);
    __privateMethod(this, _finish, finish_fn).call(this, value);
  }
  reject(error) {
    if (__privateGet(this, _isRejected) || __privateGet(this, _isResolved)) {
      return;
    }
    __privateSet(this, _isRejected, true);
    __privateMethod(this, _finish, finish_fn).call(this, error);
  }
  resolved() {
    return __privateGet(this, _isResolved);
  }
  finished() {
    return __privateGet(this, _isResolved) || __privateGet(this, _isRejected);
  }
  value() {
    return __privateGet(this, _value);
  }
  async valueOrThrow() {
    await __privateGet(this, _taskPromise);
    if (__privateGet(this, _isRejected)) {
      throw __privateGet(this, _value);
    }
    return __privateGet(this, _value);
  }
  static create(opts) {
    return new _Deferred(opts);
  }
  static async race(awaitables) {
    const deferredWithTimeout = /* @__PURE__ */ new Set();
    try {
      const promises = awaitables.map((value) => {
        if (value instanceof _Deferred) {
          if (__privateGet(value, _timeoutId)) {
            deferredWithTimeout.add(value);
          }
          return value.valueOrThrow();
        }
        return value;
      });
      return await Promise.race(promises);
    } finally {
      for (const deferred of deferredWithTimeout) {
        deferred.reject(new Error("Timeout cleared"));
      }
    }
  }
};
_isResolved = new WeakMap();
_isRejected = new WeakMap();
_value = new WeakMap();
_resolver = new WeakMap();
_taskPromise = new WeakMap();
_timeoutId = new WeakMap();
_timeoutError = new WeakMap();
_finish = new WeakSet();
finish_fn = function(value) {
  clearTimeout(__privateGet(this, _timeoutId));
  __privateSet(this, _value, value);
  __privateGet(this, _resolver).call(this);
};
var Deferred = _Deferred;

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/util/Mutex.js
var _mutex, _a3, _locked, _acquirers;
var _Mutex = class _Mutex {
  constructor() {
    __privateAdd(this, _locked, false);
    __privateAdd(this, _acquirers, []);
  }
  // This is FIFO.
  async acquire() {
    if (!__privateGet(this, _locked)) {
      __privateSet(this, _locked, true);
      return new _Mutex.Guard(this);
    }
    const deferred = Deferred.create();
    __privateGet(this, _acquirers).push(deferred.resolve.bind(deferred));
    await deferred.valueOrThrow();
    return new _Mutex.Guard(this);
  }
  release() {
    const resolve = __privateGet(this, _acquirers).shift();
    if (!resolve) {
      __privateSet(this, _locked, false);
      return;
    }
    resolve();
  }
};
_locked = new WeakMap();
_acquirers = new WeakMap();
__publicField(_Mutex, "Guard", (_a3 = class {
  constructor(mutex) {
    __privateAdd(this, _mutex, void 0);
    __privateSet(this, _mutex, mutex);
  }
  [disposeSymbol]() {
    return __privateGet(this, _mutex).release();
  }
}, _mutex = new WeakMap(), _a3));
var Mutex = _Mutex;

// ../../../node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js
var __addDisposableResource = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var instances = /* @__PURE__ */ new WeakSet();
function moveable(Class, _2) {
  let hasDispose = false;
  if (Class.prototype[disposeSymbol]) {
    const dispose = Class.prototype[disposeSymbol];
    Class.prototype[disposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return dispose.call(this);
    };
    hasDispose = true;
  }
  if (Class.prototype[asyncDisposeSymbol]) {
    const asyncDispose = Class.prototype[asyncDisposeSymbol];
    Class.prototype[asyncDisposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return asyncDispose.call(this);
    };
    hasDispose = true;
  }
  if (hasDispose) {
    Class.prototype.move = function() {
      instances.add(this);
      return this;
    };
  }
  return Class;
}
function throwIfDisposed(message = (value) => {
  return `Attempted to use disposed ${value.constructor.name}.`;
}) {
  return (target, _2) => {
    return function(...args) {
      if (this.disposed) {
        throw new Error(message(this));
      }
      return target.call(this, ...args);
    };
  };
}
function invokeAtMostOnceForArguments(target, _2) {
  const cache = /* @__PURE__ */ new WeakMap();
  let cacheDepth = -1;
  return function(...args) {
    if (cacheDepth === -1) {
      cacheDepth = args.length;
    }
    if (cacheDepth !== args.length) {
      throw new Error("Memoized method was called with the wrong number of arguments");
    }
    let freshArguments = false;
    let cacheIterator = cache;
    for (const arg of args) {
      if (cacheIterator.has(arg)) {
        cacheIterator = cacheIterator.get(arg);
      } else {
        freshArguments = true;
        cacheIterator.set(arg, /* @__PURE__ */ new WeakMap());
        cacheIterator = cacheIterator.get(arg);
      }
    }
    if (!freshArguments) {
      return;
    }
    return target.call(this, ...args);
  };
}
function guarded(getKey = function() {
  return this;
}) {
  return (target, _2) => {
    const mutexes = /* @__PURE__ */ new WeakMap();
    return async function(...args) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const key = getKey.call(this);
        let mutex = mutexes.get(key);
        if (!mutex) {
          mutex = new Mutex();
          mutexes.set(key, mutex);
        }
        const _3 = __addDisposableResource(env_1, await mutex.acquire(), true);
        return await target.call(this, ...args);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        const result_1 = __disposeResources(env_1);
        if (result_1)
          await result_1;
      }
    };
  };
}

export {
  F,
  S,
  Nr,
  N,
  j,
  ne,
  ie,
  fe,
  k,
  E,
  se,
  le,
  xr,
  he,
  J,
  xe,
  be,
  kr,
  ge,
  br,
  gr,
  Se,
  wr,
  Ee,
  Oe,
  Ae,
  _e,
  Ie,
  Te,
  Pe,
  Au,
  disposeSymbol,
  asyncDisposeSymbol,
  DisposableStack,
  AsyncDisposableStack,
  EventEmitter,
  EventSubscription,
  isNode,
  DEFERRED_PROMISE_DEBUG_TIMEOUT,
  assert,
  isErrorLike,
  isErrnoException,
  rewriteError,
  createProtocolErrorMessage,
  importDebug,
  debug,
  setLogCapture,
  getCapturedLogs,
  CustomError,
  TimeoutError,
  ProtocolError,
  UnsupportedOperation,
  TargetCloseError,
  errors,
  debugError,
  DEFAULT_VIEWPORT,
  createEvaluationError,
  createClientError,
  PuppeteerURL,
  withSourcePuppeteerURLIfNone,
  getSourcePuppeteerURLIfAvailable,
  valueFromRemoteObject,
  isString,
  isNumber,
  isPlainObject,
  isRegExp,
  isDate,
  evaluationString,
  addPageBinding,
  pageBindingInitString,
  importFSPromises,
  getReadableAsBuffer,
  getReadableFromProtocolStream,
  getPageContent,
  validateDialogType,
  timeout,
  UTILITY_WORLD_NAME,
  SOURCE_URL_REGEX,
  getSourceUrlComment,
  waitForHTTP,
  NETWORK_IDLE_TIME,
  CDPSessionEvent,
  CDPSession,
  Deferred,
  Mutex,
  moveable,
  throwIfDisposed,
  invokeAtMostOnceForArguments,
  guarded
};
/*! Bundled license information:

puppeteer-core/lib/esm/third_party/rxjs/rxjs.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/disposable.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/third_party/mitt/mitt.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/assert.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/environment.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Debug.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Errors.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/util.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/decorators.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=chunk-BYNAIBLV.js.map
